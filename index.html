<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カラー選択ツール</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f4f7f6;
            min-height: 100vh;
            display: flex;
            flex-direction: column; 
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 500px; 
            width: 100%;
            margin-bottom: 20px; 
        }

        .color-palette-section {
            margin-bottom: 25px;
        }

        .palette-container {
            position: relative;
            width: 100%;
            height: 250px;
            border-radius: 10px;
            overflow: hidden;
            cursor: crosshair;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
        }

        #colorPalette {
            width: 100%;
            height: 100%;
            display: block;
            transition: filter 0.05s ease;
        }

        .palette-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 3px solid white;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5), inset 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .brightness-slider-container {
            margin-bottom: 20px;
        }

        .brightness-slider-container label {
            display: block;
            margin-bottom: 10px;
            color: #333;
            font-weight: bold;
            font-size: 0.9rem;
        }

        #brightnessSlider {
            width: 100%;
            height: 25px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, #000, #fff);
            border-radius: 10px;
            outline: none;
            cursor: pointer;
        }

        #brightnessSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: white;
            border: 3px solid #667eea;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        #brightnessSlider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: white;
            border: 3px solid #667eea;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* [修正] .controls-container スタイル削除 */

        .eyedropper-section {
            /* [修正] 元のスタイルに戻す */
            margin-bottom: 25px;
            text-align: center;
        }

        .eyedropper-btn {
            background: #667eea;
            color: white;
            border: none;
            /* [修正] 元のスタイルに戻す */
            padding: 12px 25px;
            font-size: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
            font-weight: bold;
            width: 100%; /* 100% に戻す */
            /* white-space: nowrap; 削除 */
        }

        .eyedropper-btn:hover {
            background: #5568d3;
        }

        .eyedropper-btn:active {
            background: #4451b8;
        }

        .eyedropper-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .color-display {
            display: flex;
            align-items: center;
            gap: 15px;
            position: relative; 
            /* [修正] flex: 1 削除 */
        }

        .favorite-btn {
            position: absolute;
            top: -8px;
            left: -8px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: none;
            background: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            cursor: pointer;
            font-size: 16px;
            color: #ccc;
            transition: all 0.2s ease;
            z-index: 10;
            line-height: 26px;
            padding: 0;
        }
        .favorite-btn:hover {
            transform: scale(1.1);
            color: #ff6b6b;
        }
        .favorite-btn.active {
            color: #ff6b6b;
            background: #fff0f0;
        }

        .color-preview {
            width: 80px;
            height: 80px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            border: 3px solid #eee;
            flex-shrink: 0;
        }

        .color-code-item {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            min-width: 0;
        }

        .color-code-item input {
            flex: 1;
            padding: 10px 14px;
            border: 2px solid #eee;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            background: #f9f9f9;
            text-align: center;
            font-weight: bold;
            min-width: 0;
        }

        .color-code-item input:focus {
            outline: none;
            border-color: #667eea;
            background: white;
        }

        .copy-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 15px;
            transition: background 0.2s;
            white-space: nowrap;
            font-weight: bold;
        }

        .copy-btn:hover {
            background: #5568d3;
        }

        .copy-btn:active {
            background: #4451b8;
        }

        .copy-btn.copied {
            background: #10b981;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
            pointer-events: none;
            z-index: 1000;
        }

        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }

        .notification.error {
            background: #e11d48;
        }

        .storage-container {
            display: flex;
            gap: 20px;
            margin-top: 25px;
        }

        .storage-section {
            margin-top: 0;
            flex: 1;
            min-width: 0;
        }

        .storage-section h4 {
            color: #555;
            font-weight: bold;
            margin-bottom: 10px;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
            font-size: 1rem;
        }
        .color-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-height: 100px;
            overflow-y: auto;
            padding: 8px;
            background: #f9f9f9;
            border-radius: 10px;
        }
        .color-list-item {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.2s;
            position: relative;
            flex-shrink: 0;
        }
        .color-list-item:hover {
            transform: scale(1.1);
        }
        .delete-btn {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 18px;
            height: 18px;
            background: #333;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 12px;
            line-height: 17px;
            text-align: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            font-weight: bold;
            z-index: 2;
        }
        .color-list-item:hover .delete-btn {
            opacity: 1;
        }

        .footer-text {
            text-align: center;
            color: #aaa;
            font-size: 12px;
        }


        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }

            /* [修正] .controls-container 関連削除 */
            
            .color-display {
                flex-direction: column;
                gap: 15px;
            }

            .favorite-btn {
                top: 5px;
                right: 5px;
                left: auto;
            }

            .color-preview {
                width: 100%;
                height: 70px;
            }
            
            .storage-container {
                flex-direction: column;
                gap: 15px;
                margin-top: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- カラーパレット -->
        <div class="color-palette-section">
            <div class="palette-container" id="paletteContainer">
                <canvas id="colorPalette"></canvas>
                <div class="palette-cursor" id="paletteCursor"></div>
            </div>

            <!-- 明度スライダー -->
            <div class="brightness-slider-container">
                <label for="brightnessSlider">明度調整</label>
                <input type="range" id="brightnessSlider" min="0" max="100" value="100">
            </div>
        </div>

        <!-- [修正] スポイト機能を元の位置に戻す -->
        <div class="eyedropper-section">
            <button id="eyedropperBtn" class="eyedropper-btn">
                スポイトで色を取得
            </button>
        </div>

        <!-- [修正] controls-container から出す -->
        <div class="color-display">
            <button class="favorite-btn" id="favoriteBtn" title="お気に入りに追加">♡</button>
            <div class="color-preview" id="colorPreview"></div>
            <div class="color-code-item">
                <input type="text" id="hexCode" readonly>
                <button class="copy-btn" id="copyBtn">コピー</button>
            </div>
        </div>

        <!-- [修正] お気に入りと履歴のコンテナ -->
        <div class="storage-container">
            <!-- お気に入りセクション -->
            <div class="storage-section">
                <h4>お気に入り</h4>
                <div class="color-list" id="favoritesList">
                    <!-- お気に入りアイテムがここに追加されます -->
                </div>
            </div>

            <!-- コピー履歴セクション -->
            <div class="storage-section">
                <h4>コピー履歴</h4>
                <div class="color-list" id="historyList">
                    <!-- コピー履歴がここに追加されます -->
                </div>
            </div>
        </div> <!-- .storage-container 終了 -->

    </div>

    <div class="notification" id="notification"></div>

    <!-- フッター -->
    <div class="footer-text">
        ちいくじカラーピッカー
    </div>

    <script>
        // 要素の取得
        const eyedropperBtn = document.getElementById('eyedropperBtn');
        const colorPalette = document.getElementById('colorPalette');
        const paletteContainer = document.getElementById('paletteContainer');
        const paletteCursor = document.getElementById('paletteCursor');
        const brightnessSlider = document.getElementById('brightnessSlider');
        const colorPreview = document.getElementById('colorPreview');
        const hexCode = document.getElementById('hexCode');
        const notification = document.getElementById('notification');
        const copyBtn = document.getElementById('copyBtn');
        const favoriteBtn = document.getElementById('favoriteBtn');
        const favoritesList = document.getElementById('favoritesList');
        const historyList = document.getElementById('historyList');

        // カラーパレットの初期化
        const ctx = colorPalette.getContext('2d');
        let currentHue = 0;
        let currentSaturation = 100; // HSVのSaturation
        let currentBrightness = 100; // HSVのValue (Brightness)
        let isDragging = false;
        let notificationTimer = null; 
        
        let currentHex = '#FFFFFF'; // 現在の色 (HEX)
        let favorites = []; // お気に入りリスト
        let copyHistory = []; // コピー履歴リスト

        // localStorage キー
        const FAVORITES_KEY = 'colorPickerFavorites';
        const HISTORY_KEY = 'colorPickerHistory';

        function initPalette() {
            const rect = paletteContainer.getBoundingClientRect();
            colorPalette.width = rect.width;
            colorPalette.height = rect.height;
            drawPalette();
            colorPalette.style.filter = `brightness(${currentBrightness}%)`;
        }

        function showNotification(message, isError = false) {
            if (notificationTimer) {
                clearTimeout(notificationTimer);
            }
            notification.textContent = message;
            if (isError) {
                notification.classList.add('error');
            } else {
                notification.classList.remove('error');
            }
            notification.classList.add('show');
            notificationTimer = setTimeout(() => {
                notification.classList.remove('show');
                notificationTimer = null;
            }, 3000); 
        }

        function drawPalette() {
            const width = colorPalette.width;
            const height = colorPalette.height;
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    const hue = (x / width) * 360;
                    const saturation = 100 - (y / height) * 100;
                    const value = 100; 
                    const rgb = hsvToRgb(hue, saturation, value);
                    ctx.fillStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }

        function handlePaletteInteraction(e) {
            const rect = paletteContainer.getBoundingClientRect();
            let x, y;
            if (e.type.includes('touch')) {
                if (!e.touches || e.touches.length === 0) return;
                x = e.touches[0].clientX - rect.left;
                y = e.touches[0].clientY - rect.top;
            } else {
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            }
            x = Math.max(0, Math.min(x, rect.width));
            y = Math.max(0, Math.min(y, rect.height));
            paletteCursor.style.left = x + 'px';
            paletteCursor.style.top = y + 'px';
            currentHue = (x / rect.width) * 360;
            currentSaturation = 100 - (y / rect.height) * 100;
            updateColor();
        }

        paletteContainer.addEventListener('mousedown', (e) => {
            isDragging = true;
            handlePaletteInteraction(e);
        });
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                handlePaletteInteraction(e);
            }
        });
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
        paletteContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true; 
            handlePaletteInteraction(e);
        });
        paletteContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDragging) { 
                handlePaletteInteraction(e);
            }
        });
        paletteContainer.addEventListener('touchend', (e) => {
            isDragging = false; 
        });

        brightnessSlider.addEventListener('input', (e) => {
            currentBrightness = e.target.value; 
            updateColor();
        });

        function updateColor() {
            const h = currentHue;
            const s = currentSaturation;
            const v = currentBrightness;
            
            colorPalette.style.filter = `brightness(${v}%)`;

            const rgb = hsvToRgb(h, s, v);
            currentHex = rgbToHex(rgb.r, rgb.g, rgb.b);

            colorPreview.style.backgroundColor = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
            hexCode.value = currentHex;

            const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
            paletteCursor.style.borderColor = brightness > 128 ? '#000' : '#fff';

            updateFavoriteButtonState();
        }

        function rgbToHex(r, g, b) {
            const hex = '#' + [r, g, b].map(x => {
                const hexVal = x.toString(16);
                return hexVal.length === 1 ? '0' + hexVal : hexVal;
            }).join('');
            return hex.toUpperCase();
        }

        eyedropperBtn.addEventListener('click', async () => {
            if (!('EyeDropper' in window)) {
                showNotification('お使いのブラウザはスポイト機能に対応していません。', true);
                return;
            }
            try {
                const eyeDropper = new EyeDropper();
                const result = await eyeDropper.open();
                const hex = result.sRGBHex.toUpperCase();
                setUIColorFromHex(hex);

            } catch (e) {
                console.log('スポイトがキャンセルされました');
            }
        });

        function setUIColorFromHex(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);

            const hsv = rgbToHsv(r, g, b);
            currentHue = hsv.h;
            currentSaturation = hsv.s;
            currentBrightness = hsv.v;
            brightnessSlider.value = currentBrightness;

            const rect = paletteContainer.getBoundingClientRect();
            const x = isNaN(currentHue) ? 0 : (currentHue / 360) * rect.width;
            const y = isNaN(currentSaturation) ? rect.height : ((100 - currentSaturation) / 100) * rect.height;
            
            paletteCursor.style.left = x + 'px';
            paletteCursor.style.top = y + 'px';

            updateColor();
        }

        function rgbToHsv(r, g, b) {
            r /= 255, g /= 255, b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, v = max;
            let d = max - min;
            s = max === 0 ? 0 : d / max;

            if (max === min) {
                h = 0;
            } else {
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h: h * 360, s: s * 100, v: v * 100 };
        }

        function hsvToRgb(h, s, v) {
            h /= 360; s /= 100; v /= 100;
            let r, g, b, i, f, p, q, t;
            i = Math.floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v, g = t, b = p; break;
                case 1: r = q, g = v, b = p; break;
                case 2: r = p, g = v, b = t; break;
                case 3: r = p, g = q, b = v; break;
                case 4: r = t, g = p, b = v; break;
                case 5: r = v, g = p, b = q; break;
            }
            return { 
                r: Math.round(r * 255), 
                g: Math.round(g * 255), 
                b: Math.round(b * 255) 
            };
        }

        copyBtn.addEventListener('click', async () => {
            const textToCopy = hexCode.value;

            try {
                if (navigator.clipboard && window.isSecureContext) {
                    await navigator.clipboard.writeText(textToCopy);
                } else {
                    throw new Error('Clipboard API not available, trying execCommand.');
                }
            } catch (err) {
                console.warn('Clipboard API failed, falling back to execCommand:', err);
                
                const copyToClipboard = (text) => {
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = 0;
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        const successful = document.execCommand('copy');
                        document.body.removeChild(textarea);
                        return successful;
                    } catch (e) {
                        document.body.removeChild(textarea);
                        return false;
                    }
                };

                if (!copyToClipboard(textToCopy)) {
                    console.error('コピーに失敗しました (execCommand failed)');
                    showNotification('コピーに失敗しました。', true);
                    return;
                }
            }

            showNotification('コピーしました');
            copyBtn.classList.add('copied');
            copyBtn.textContent = '✓ 完了';
            
            setTimeout(() => {
                copyBtn.classList.remove('copied');
                copyBtn.textContent = 'コピー';
            }, 2000); 

            addHistory(currentHex);
            
            window.getSelection()?.removeAllRanges();
        });


        function updateFavoriteButtonState() {
            if (favorites.includes(currentHex)) {
                favoriteBtn.classList.add('active');
                favoriteBtn.textContent = '♥';
            } else {
                favoriteBtn.classList.remove('active');
                favoriteBtn.textContent = '♡';
            }
        }

        function renderFavorites() {
            favoritesList.innerHTML = '';
            favorites.forEach(hex => {
                const item = document.createElement('div');
                item.className = 'color-list-item';
                item.style.background = hex;
                item.dataset.hex = hex;
                item.title = hex;

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '&times;';
                
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    favorites = favorites.filter(f => f !== hex);
                    renderFavorites();
                    updateFavoriteButtonState();
                    saveFavorites();
                });

                item.addEventListener('click', () => {
                    setUIColorFromHex(hex);
                });

                item.appendChild(deleteBtn);
                favoritesList.appendChild(item);
            });
        }

        function renderHistory() {
            historyList.innerHTML = '';
            copyHistory.forEach(hex => {
                const item = document.createElement('div');
                item.className = 'color-list-item';
                item.style.background = hex;
                item.dataset.hex = hex;
                item.title = hex;

                item.addEventListener('click', () => { 
                    setUIColorFromHex(hex);
                });

                historyList.appendChild(item);
            });
        }

        function addHistory(hex) {
            copyHistory = copyHistory.filter(h => h !== hex);
            copyHistory.unshift(hex);
            if (copyHistory.length > 20) {
                copyHistory.pop();
            }
            renderHistory();
            saveHistory();
        }

        favoriteBtn.addEventListener('click', () => {
            if (favorites.includes(currentHex)) {
                favorites = favorites.filter(f => f !== currentHex);
            } else {
                favorites.unshift(currentHex);
            }
            renderFavorites();
            updateFavoriteButtonState();
            saveFavorites();
        });

        function saveFavorites() {
            try {
                localStorage.setItem(FAVORITES_KEY, JSON.stringify(favorites));
            } catch (e) {
                console.error("お気に入りの保存に失敗:", e);
                showNotification("お気に入りの保存に失敗しました。", true);
            }
        }
        function saveHistory() {
             try {
                localStorage.setItem(HISTORY_KEY, JSON.stringify(copyHistory));
             } catch (e) {
                console.error("履歴の保存に失敗:", e);
             }
        }

        function loadStorage() {
            const storedFavorites = localStorage.getItem(FAVORITES_KEY);
            const storedHistory = localStorage.getItem(HISTORY_KEY);
            if (storedFavorites) {
                try {
                    favorites = JSON.parse(storedFavorites);
                } catch (e) {
                    console.error("お気に入りデータの読み込みに失敗しました:", e);
                    favorites = [];
                }
            }
            if (storedHistory) {
                 try {
                    copyHistory = JSON.parse(storedHistory);
                 } catch (e) {
                    console.error("履歴データの読み込みに失敗しました:", e);
                    copyHistory = [];
                 }
            }
        }

        window.addEventListener('load', () => {
            loadStorage();

            initPalette();
            
            const rect = paletteContainer.getBoundingClientRect();
            const initialX = (rect.width / 2);
            const initialY = (rect.height / 2);

            paletteCursor.style.left = initialX + 'px';
            paletteCursor.style.top = initialY + 'px';
            
            currentHue = (initialX / rect.width) * 360;
            currentSaturation = 100 - (initialY / rect.height) * 100;
            
            renderFavorites();
            renderHistory();

            updateColor();
        });

        window.addEventListener('resize', () => {
            initPalette();
            
            const rect = paletteContainer.getBoundingClientRect();
            const x = isNaN(currentHue) ? 0 : (currentHue / 360) * rect.width;
            const y = isNaN(currentSaturation) ? rect.height : ((100 - currentSaturation) / 100) * rect.height;
            paletteCursor.style.left = x + 'px';
            paletteCursor.style.top = y + 'px';
        });

        if (!('EyeDropper' in window)) {
            eyedropperBtn.disabled = true;
            eyedropperBtn.textContent = 'スポイト機能非対応';
            eyedropperBtn.title = 'Chrome 95以降で利用可能です';
        }
    </script>
</body>
</html>
